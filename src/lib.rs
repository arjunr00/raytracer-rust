use rand::distributions::Uniform;

use camera::Camera;
use geom::HittableGroup;
use math::{ f_clamp, rand_f64, Rand };
use vec::ColorRGB;

pub mod camera;
pub mod geom;
pub mod math;
pub mod vec;
pub use vec::colors;

const MAX_COLORS: u32 = 255;

/// Creates a String containing a PPM representation of a single pixel
pub fn write_pixel(pixel: &ColorRGB, samples: u32) -> String {
    let scale = 1.0 / f64::from(samples);

    // Correct for gamma = 2.0
    let r = (pixel[vec::Color::R] * scale).sqrt();
    let g = (pixel[vec::Color::G] * scale).sqrt();
    let b = (pixel[vec::Color::B] * scale).sqrt();


    format!("{} {} {}\n",
        (256.0 * f_clamp(r, 0.0, 0.999)) as u32,
        (256.0 * f_clamp(g, 0.0, 0.999)) as u32,
        (256.0 * f_clamp(b, 0.0, 0.999)) as u32
    )
}

/// Creates a String containing a PPM generated by sending rays to each pixel. The image's
/// contents are described by `world`.
pub fn create_ppm(world: &HittableGroup, width: u32, height: u32, samples: u32, max_depth: u32) -> String {
    let camera = Camera::new(width, height);

    let mut ppm = format!("P3\n{} {}\n{}\n", width, height, MAX_COLORS);
    let total_pixels = width * height;

    let zero_to_one = Uniform::from(0.0..1.0);
    let rng = rand::thread_rng();
    let mut rand = Rand { dist: zero_to_one, rng };

    for i in 0..height {
        for j in 0..width {
            let mut color = ColorRGB::new(0.0, 0.0, 0.0);
            for _ in 0..samples {
                let u = ((j as f64) + rand_f64(&mut rand)) / f64::from(width - 1);
                let v = ((i as f64) + rand_f64(&mut rand)) / f64::from(height - 1);

                let r = camera.ray(u, v);

                color += r.get_color(world, max_depth, &mut rand);
            }

            ppm.push_str(&write_pixel(&color, samples));

            let pixel_num = j + 1 + (i * width);
            eprint!("\r{}/{} pixels rendered", pixel_num, total_pixels);
        }
    }

    eprintln!("\nDone.");
    ppm
}
