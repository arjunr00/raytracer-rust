use std::fs::{ File };
use std::io::{ prelude::{ Write, Seek }, SeekFrom };
use std::path::Path;
use std::sync::{ Arc, Mutex };
use rand::distributions::Uniform;

use camera::Camera;
use geom::World;
use math::{ f_clamp, rand_f64, Rand };
use threadpool::ThreadPool;
use vec::ColorRGB;

pub mod accel;
pub mod camera;
pub mod geom;
pub mod material;
pub mod math;
pub mod threadpool;
pub mod vec;
pub use vec::colors;

const MAX_COLORS: u32 = 255;

pub struct ImageConfig {
    pub width: u32,
    pub height: u32,
    pub samples: u32,
    pub max_depth: u32,
    pub background: Arc<dyn Fn(f64) -> ColorRGB + Send + Sync>
}

/// Creates a String containing a PPM representation of a single pixel
pub fn write_pixel(pixel: &ColorRGB, samples: u32) -> String {
    let scale = 1.0 / f64::from(samples);

    // Correct for gamma = 2.0
    let r = (pixel[vec::Color::R] * scale).sqrt();
    let g = (pixel[vec::Color::G] * scale).sqrt();
    let b = (pixel[vec::Color::B] * scale).sqrt();


    format!("{} {} {}\n",
        (256.0 * f_clamp(r, 0.0, 0.999)) as u32,
        (256.0 * f_clamp(g, 0.0, 0.999)) as u32,
        (256.0 * f_clamp(b, 0.0, 0.999)) as u32
    )
}

/// Creates a String containing a PPM generated by sending rays to each pixel. The image's
/// contents are described by `world`.
pub fn create_ppm(world: &World, camera: &Camera, config: &ImageConfig) -> String {
    let width = config.width;
    let height = config.height;
    let samples = config.samples;
    let max_depth = config.max_depth;

    let mut ppm = format!("P3\n{} {}\n{}\n", width, height, MAX_COLORS);
    let total_pixels = width * height;

    let zero_to_one = Uniform::from(0.0..1.0);
    let rng = rand::thread_rng();
    let mut rand = Rand { dist: zero_to_one, rng };

    for i in 0..height {
        for j in 0..width {
            let mut color = ColorRGB::new(0.0, 0.0, 0.0);
            for _ in 0..samples {
                let u = ((j as f64) + rand_f64(&mut rand)) / f64::from(width - 1);
                let v = ((i as f64) + rand_f64(&mut rand)) / f64::from(height - 1);

                let r = camera.ray(u, v, &mut rand);

                color += r.get_color(world, &*config.background, max_depth, &mut rand);
            }

            ppm.push_str(&write_pixel(&color, samples));

            let pixel_num = j + 1 + (i * width);
            eprint!("\r{}/{} pixels rendered", pixel_num, total_pixels);
        }
    }

    eprintln!("\nDone.");
    ppm
}

pub fn write_ppm_threaded(world: Arc<World>, camera: Arc<Camera>, filename: &str, config: Arc<ImageConfig>) {
    let width = config.width;
    let height = config.height;
    let samples = config.samples;
    let max_depth = config.max_depth;
    let total_pixel_count = width * height;

    let sample_count = Arc::new(Mutex::new(0));
    let pixels = Arc::new(Mutex::new(vec![colors::BLACK; total_pixel_count as usize]));
    let mut file = File::create(&Path::new(filename)).unwrap();

    let cpu_count = num_cpus::get();
    eprintln!("Spawning thread pool with {} workers", cpu_count);
    let mut pool = ThreadPool::new(cpu_count);

    for s in 0..samples {
        let sample_count = sample_count.clone();
        let pixels = pixels.clone();
        let world = world.clone();
        let camera = camera.clone();
        let bg_func = config.background.clone();

        pool.execute(move || {
            let zero_to_one = Uniform::from(0.0..1.0);
            let rng = rand::thread_rng();
            let mut rand = Rand { dist: zero_to_one, rng };

            let mut ppm = format!("P3\n{} {}\n{}\n", width, height, MAX_COLORS);
            for i in 0..height {
                let slice_start = (i * width) as usize;
                let slice_end = ((i + 1) * width) as usize;

                let mut scanline = vec![colors::BLACK; slice_end - slice_start];

                for j in 0..width {
                    let u = ((j as f64) + rand_f64(&mut rand)) / f64::from(width - 1);
                    let v = ((i as f64) + rand_f64(&mut rand)) / f64::from(height - 1);

                    let r = camera.ray(u, v, &mut rand);

                    let ray_color = r.get_color(&world, &*bg_func, max_depth, &mut rand);

                    if let Some(color) = scanline.get_mut(j as usize) {
                        *color += ray_color
                    }
                }

                let mut pixels = pixels.lock().unwrap();
                for (i, pixel) in pixels[slice_start..slice_end].iter().enumerate() {
                    scanline[i] += pixel;
                }
                (*pixels).splice(slice_start..slice_end, scanline);
            }

            let pixels = pixels.lock().unwrap();
            for pixel in &*pixels {
                ppm.push_str(&write_pixel(&pixel, s));
            }

            let mut sample_count = sample_count.lock().unwrap();
            *sample_count += 1;
            eprint!("\r{} samples done", sample_count);
        });
    }

    pool.finish_with(move || {
        eprint!("\n");
        let mut ppm = format!("P3\n{} {}\n{}\n", width, height, MAX_COLORS);
        let pixels = pixels.lock().unwrap();
        for pixel in &*pixels {
            ppm.push_str(&write_pixel(&pixel, samples));
        }

        file.seek(SeekFrom::Start(0)).unwrap();
        file.write_all(&ppm.as_bytes()).unwrap();
    });
}

/// Similar to create_ppm, but performs one sample per pixel, writes to a file, and then performs
/// the next sample. Slower, but useful for watching progress.
pub fn write_ppm(world: &World, camera: &Camera, filename: &str, config: &ImageConfig) {
    let width = config.width;
    let height = config.height;
    let samples = config.samples;
    let max_depth = config.max_depth;

    let mut pixels: Vec<ColorRGB> = vec![];
    let total_pixels = width * height;

    let zero_to_one = Uniform::from(0.0..1.0);
    let rng = rand::thread_rng();
    let mut rand = Rand { dist: zero_to_one, rng };

    let mut file = File::create(&Path::new(filename)).unwrap();
    for s in 0..samples {
        file.seek(SeekFrom::Start(0)).unwrap();
        let mut ppm = format!("P3\n{} {}\n{}\n", width, height, MAX_COLORS);
        eprintln!("\nSample {}:", s);
        for i in 0..height {
            for j in 0..width {
                let u = ((j as f64) + rand_f64(&mut rand)) / f64::from(width - 1);
                let v = ((i as f64) + rand_f64(&mut rand)) / f64::from(height - 1);

                let r = camera.ray(u, v, &mut rand);

                let pixel_num = j + (i * width);
                if pixels.len() <= pixel_num as usize {
                    pixels.push(colors::BLACK);
                }
                match pixels.get_mut(pixel_num as usize) {
                    None => pixels.push(r.get_color(world, &*config.background, max_depth, &mut rand)),
                    Some(color) => *color += r.get_color(world, &*config.background, max_depth, &mut rand)
                };

                eprint!("\r{}/{} pixels rendered", pixel_num + 1, total_pixels);
            }
        }

        for pixel in &pixels {
            ppm.push_str(&write_pixel(&pixel, s));
        }
        file.write_all(&ppm.as_bytes()).unwrap();
    }

    eprintln!("\nDone.");
}
